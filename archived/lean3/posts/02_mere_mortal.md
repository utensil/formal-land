Hi @**Alcides Fonseca** , I really like [your post](https://wiki.alcidesfonseca.com/blog/lean-tutorial-mere-mortals/) and [tutorial](https://github.com/alcides/lean3_tutorial), particularly the personal touch during the learning process.

I went through a similar learning experience with Agda, Idris and Coq (plus maybe  HOL Light and Isabelle/HOL ). While I can bear the burden of cognition of grammars, they are just not the languages I would appreciate to write and read. I know Lean from the manifest on  https://lean-forward.github.io/, particularly the critics regarding the existing tools, the pain points described felt so correct so I checked the solution provided by the ones who criticize, and it turns out to be a perfect foundation for the claimed solution.

As a mortal with my own limitations and motivations,  my perception of Lean is a versatile language that corresponds to the versatile world of programming, reasoning, mathematics and real-world applications (all these for verifying), but it's also based on one core essence, namely the Curryâ€“Howard correspondence, that unifies all different styles and blurs the boundary between coding and proving. So the foundation is simple enough and powerful enough, that's a good start and I mean this by "a perfect foundation". 

Then came the proofs written in this language and the world become diversified. There're different tutorials, games, documentation only presenting Lean as an incomplete projection, advocating one or two styles. And when one reads real code written in Lean such as mathlib, even one can tell there's certain control of style, as a group effort, it's still utilizing all aspects in Lean and thus not so accessible to someone who just learned some fragments of Lean. One of the things I struggled with when I start reading and writing Lean is that when to use which style and how are they properly combined in one proof and the supporting lemma of the proof and how can one wrap their mind around this hodgepodge.

Eventually, I reached the "Aha!" moment and posted in https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/4.20proof.20styles to share the moment(actually there's the 5th style, conv mode proof). With continuous efforts after the post, I found myself able to switch between different equivalent styles in more complicated proofs and the style choices in mathlib started to make sense for me and a mental model start growing on me.

During learning, it's so natural for one to pick a particular linear path, but there will be a point the general grasp of the tool becomes nonlinear and multidimensional. Namely, I hated the tactics mode for its readability but loved the tooling support when finding a way to prove and writing it. But it soon becomes merely the crutch and I realized that I always never needed such step-by-step guidance for common programming but my own mind that's capable of planning things out. The structural proof is something that resembles more of the elements of hand-written proof and it reads like a natural language. As learned in "How to write proofs: a quick guide" by Eugenia Cheng, proofs are found not only by working from the goal side (the backward proof using tactics) and not only by working form the hypothesis side ( the forward proof), but both ends like building a bridge to meet in the middle, and he emphasize that the completed proof should be better written in the forward style so other can be convinced following a natural time flow and convincing someone the correctness of the proof is the ultimate goal of proof, no matter it's backed by some computers. The structural proof also provided more hints than bare bone minimal that computer would accept as a formal proof, if well written, it would clearly reflect the whole planning process of the proof and the intermediate goals as stepping stones. It can be further enhanced with literate style syntax that's useless for computers but so helpful for readers. Besides these two major directions, term mode proof is actually more accessible to programmer, since it turns the proving process into a type filling game and it's succinct for some irreducible lemmas. My favorite style is the calc mode, since it feels doing math and greatly helps the reading to understand what's happening, but current implementation has not reached the full potential of this paradigm (like doing even crazier things with both side and the operation and goals) thus it can't write a full proof for a complicated proposition. The conv mode is like the tactics mode in the sense it also breaks things down but it provides more freedom during the process.

The above has only addressed one language of your three. I haven't dived into the details of the functional programming language and the meta-programming language yet. So far I feel the former is very limited and also it doesn't have a rich ecosystem to back it and the main users of Lean don't seem to have heavy use cases for it for now so it's not growing at its full speed, both for the language aspect and the library aspect(see Rust for such an evolving community focusing on making the language more ergonomic for common programming). But I do need it to be a complete functional programming language to implement efficient data structures and algorithms to verify against and Lean also haven't found a partner language to verify against. On the other hand, the meta-programming language is in an exactly opposite position: it's well established on the experience of do notation and has heavy use cases in tactics development which will drive its growth. The obvious missing piece I can see is the interoperability with other languages and ATP tools but it's possibly mostly due to what the former lacks.

Summarizing the above, Lean provides both a rich mindset and toolset for the users to explore with so it has great potential in all the programming paradigms it supports, but it's still in a not so mature stage so all aspects of its potentials are not evenly growing, and it suffers from its own weight as a versatile programming language for newcomers and the diversified audience it targets, varying from common programmers, mathematicians, undergraduate students, formalization experts and other mortals such as me who is driven by the dire of formalizing some particular programmable applications with the sound foundation in pure math, building a bridge from pure conceptual world to executable code for practical applications.