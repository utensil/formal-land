import Mathlib.GroupTheory.SpecificGroups.Alternating
import Mathlib.GroupTheory.SpecificGroups.Cyclic
import Mathlib.GroupTheory.SpecificGroups.Dihedral
import Mathlib.GroupTheory.SpecificGroups.KleinFour
import Mathlib.GroupTheory.SpecificGroups.Quaternion
import Mathlib.GroupTheory.Subgroup.Actions
import Mathlib.GroupTheory.Subgroup.Basic
import Mathlib.GroupTheory.Subgroup.Finite
import Mathlib.GroupTheory.Subgroup.MulOpposite
import Mathlib.GroupTheory.Subgroup.Pointwise
import Mathlib.GroupTheory.Subgroup.Saturated
import Mathlib.GroupTheory.Subgroup.Simple
import Mathlib.GroupTheory.Subgroup.ZPowers
import Mathlib.RepresentationTheory.Basic
import Mathlib.RepresentationTheory.Action.Basic
import Mathlib.CategoryTheory.Endomorphism
import Mathlib.GroupTheory.GroupAction.Basic
import Mathlib.GroupTheory.GroupAction.DomAct.Basic
import Mathlib.Algebra.DirectSum.Algebra
import Mathlib.LinearAlgebra.Matrix.Basis
import Mathlib.LinearAlgebra.Matrix.NonsingularInverse
import Mathlib.Data.Matrix.Invertible
import Mathlib.LinearAlgebra.Eigenspace.Basic
import Mathlib.GroupTheory.Index
import Mathlib.LinearAlgebra.Eigenspace.Triangularizable
import Mathlib.LinearAlgebra.Matrix.Spectrum
import Mathlib.GroupTheory.FreeGroup.IsFreeGroup
import Mathlib.LinearAlgebra.Matrix.GeneralLinearGroup
import Mathlib.LinearAlgebra.QuadraticForm.IsometryEquiv
import Mathlib.Tactic

-- Inspired by Finite symmetric groups in Physics
-- Following Representations and Characters of Groups

#check Representation.trivial

#check Module.End

#check DistribMulAction.toModuleEnd

#check CategoryTheory.End

#check CategoryTheory.Aut

#check Action.ρAut

#check Fact

#check IsCyclic.exists_generator

#check isCyclic_of_prime_card

variable (p : ℕ) [Fact p.Prime] (F : Type uF) [Field F] (ι : Type uι) [Finite ι] [LT ι] (R : Type uR) [Ring R] -- (fp : ι → F)

-- a list of indices, sorted
abbrev Model.Index := {l : List ι // l.Sorted (· < ·) }

def fp := Model.Index ι →₀ F

def e(g : fp F ι) : fp F ι := g

#check Fin p

-- def Fp : Fin p → F := sorry

-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Action.20of.20permutations.20on.20functions.2E

instance : MulAction (Equiv.Perm β)ᵐᵒᵖ β := sorry

variable (α β : Type*) in
#synth MulAction ((Equiv.Perm α)ᵐᵒᵖ)ᵈᵐᵃ (α → β) -- works


-- variable (α β : Type*) in
-- #synth MulAction ((Equiv.Perm α)ᵈᵐᵃ)ᵐᵒᵖ (α → β) -- fails

#minimize_imports

#check Group

#check Semigroup.mul_assoc

#check MulOneClass.one_mul

#check MulOneClass.mul_one

#check Group.mul_left_inv

#check Subgroup

variable {G H : Type uG} [Group G] [Group H] (K L : Subgroup G)

#check Subgroup G

#check G × H

#check Prod.instGroup

#check Group.FG

#check MulHom

#check MonoidHom

#check Action.Hom

#check Representation.asGroupHom

#check Subgroup.Normal

#check Subgroup.index

#check HasQuotient.Quotient G K

/-
failed to synthesize instance
  HDiv (Type uG) (Subgroup G) ?m.4221
-/
-- #check G / K

#check IsSimpleGroup

#check QuotientGroup.instHasQuotientSubgroup

#check QuotientGroup.Quotient.group

#check LinearMap.ker

#check Set.preimage_kernImage

#check Setoid.ker

#check Filter.ker

#check MonoidHom.ker

#check RingHom.ker

#check MonoidHom.range

#check QuotientGroup.quotientKerEquivRange

#check QuotientGroup.quotientInfEquivProdNormalQuotient

#check QuotientGroup.quotientQuotientEquivQuotient

#check Basis

#check Module.Finite.of_basis

#check Module.Free.finite_basis

#check Basis.ofVectorSpace

#check FiniteDimensional.finBasis

#check Basis.ofVectorSpaceIndex

/- The `Subgroup` generated by a set. -/
-- def closure (k : Set G) : Subgroup G :=
--   sInf { K | k ⊆ K }
#check Subgroup.closure

/- The span of a set `s ⊆ M` is the smallest submodule of M that contains `s`. -/
-- def span (s : Set M) : Submodule R M :=
--   sInf { p | s ⊆ p }
#check Submodule.span

#check Submodule R (ι →₀ R)

#synth Module R (ι →₀ R)

/- Interprets (l : α →₀ R) as linear combination of the elements in the family (v : α → M) and
    evaluates this linear combination. -/
-- protected def total : (α →₀ R) →ₗ[R] M :=
--   Finsupp.lsum ℕ fun i => LinearMap.id.smulRight (v i)
#check Finsupp.total

/- `LinearIndependent R v` states the family of vectors `v` is linearly independent over `R`. -/
-- def LinearIndependent : Prop :=
--   LinearMap.ker (Finsupp.total ι M R v) = ⊥
#check LinearIndependent

#check Module.rank

#check Module.Free.chooseBasis

#check Basis.coord

#check Basis.exists_basis

#check DirectSum

#check Module.Free.directSum

#check DirectSum.instAlgebraDirectSumSemiring

#check DirectSum.add_apply

#check LinearMap

#check LinearMap.ker

#check LinearMap.range

#check rank_range_add_rank_ker

#check LinearEquiv

#check Basis.map

#check LinearEquiv.ofRankEq

#check Module.End

#check Module.End.semiring

-- TODO: PR?
-- #check Module.End.algebra
#check Module.End.instAlgebra

#check DistribMulAction.toLinearMap

#check DistribMulAction.toModuleEnd

#check LinearMap.toMatrix

#check linearMap_toMatrix_mul_basis_toMatrix

#check Matrix

section

variable (l m n: Type u) (α : Type uα) [Fintype l] [Fintype m] [Fintype n] [Mul α] [AddCommMonoid α] (x : Matrix l m α) (y : Matrix m n α) (z : Matrix l n α)

#check x * y

#synth HMul (Matrix l m α) (Matrix m n α) (Matrix l n α)

end

#check Matrix.instHMulMatrixMatrixMatrix

#check Matrix.mul_apply

#check Matrix.sum_apply

#check Matrix.toLin

#check Matrix.Represents

#check Matrix.isRepresentation

#check Matrix.isRepresentation.toEnd

#check PiToModule.fromMatrix

#check Matrix.inv

#check Matrix.invOf_eq

#check Matrix.invOf_eq_nonsing_inv

#check Matrix.invertibleOfDetInvertible

-- TODO: an endomorphism is invertible iff the matrix is invertible

#check algEquivMatrix

-- change of basis matrix
#check basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix

#check Module.End.eigenspace

#check Module.End.HasEigenvalue

#check Module.End.HasEigenvector

#check Module.End.Eigenvalues

/- The generalized eigenspace for a linear map `f`, a scalar `μ`, and an exponent `k ∈ ℕ` is the
kernel of `(f - μ • id) ^ k`. (Def 8.10 of [axler2015]). Furthermore, a generalized eigenspace for
some exponent `k` is contained in the generalized eigenspace for exponents larger than `k`. -/
-- def generalizedEigenspace (f : End R M) (μ : R) : ℕ →o Submodule R M where
--   toFun k := LinearMap.ker ((f - algebraMap R (End R M) μ) ^ k)
--   monotone' k m hm := by
--     simp only [← pow_sub_mul_pow _ hm]
--     exact
--       LinearMap.ker_le_ker_comp ((f - algebraMap R (End R M) μ) ^ k)
--         ((f - algebraMap R (End R M) μ) ^ (m - k))
#check Module.End.generalizedEigenspace

#check OrderHom

#check Module.End.eigenspaces_independent

#check Module.End.eigenvectors_linearIndependent

#check Module.End.exists_eigenvalue

#check Matrix.IsHermitian.det_eq_prod_eigenvalues

#check Basis.det

#check LinearMap.det

#check Subgroup.zpowers

#check IsFreeGroup.Generators

#check Matrix.diag

#check Matrix.diagonal

#check LinearMap.IsProj

#check LinearMap.isProj_iff_idempotent

-- TODO: л is projection of a vector space V. Then V = Im л 0 Ker л.

#check Submodule.prod

#check LinearMap.coprod

#check Matrix.GeneralLinearGroup

#check Matrix.ext'

#check Representation

#check Representation.asGroupHom

#check Representation.asAlgebraHom

#check Representation.asModuleEquiv

#check Representation.ofMulAction

#check Representation.ofDistribMulAction

#check Representation.linHom

#find_home QuadraticForm.isometryEquivBasisRepr

-- section

-- variable {k G V: Type*}  [CommRing k] [Monoid G] [AddCommMonoid V] [Module k V]

-- variable (n : Type uN) [DecidableEq n] [Fintype n]

-- variable (ρ₁ ρ₂ : Representation k G V) (T' : Matrix.GeneralLinearGroup n k)

-- #check T'⁻¹

-- #check Matrix.GeneralLinearGroup.toLin T'

-- def Representation.equivalent : Prop :=
--   ∃ T : Matrix.GeneralLinearGroup n k,
--     ∀ g, ρ₁ g = T⁻¹ ∘ₗ ρ₂ g ∘ₗ T
-- end
